/*
NowCoder生活在充满危险和阴谋的年代。为了生存，他首次发明了密码，用于军队的消息传递。假设你是军团中的一名军官，需要把发送来的消息破译出来、并提
供给你的将军。
消息加密的办法是：对消息原文中的每个字母，分别用该字母之后的第5个字母替换（例如：消息原文中的每个字母A 都分别替换成字母F），其他字符不 变，并且消息原文的所有字母都是大写的。密码中的字母与原文中的字母对应关系如下。
密码字母：A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
原文字母：V W X Y Z A B C D E F G H I J K L M N O P Q R S T U
链接：https://www.nowcoder.com/questionTerminal/9f6b8f6ec26d44cfb8fc8c664b0edb6b
来源：牛客网

输入描述:
输入包括多组数据，每组数据一行，为收到的密文。
密文仅有空格和大写字母组成。


输出描述:
对应每一组数据，输出解密后的明文。
示例1
输入
HELLO WORLD
SNHJ
输出
CZGGJ RJMGY
NICE
*/



#include <stdio.h>
 
int main() {
    int c;
    while ((c = getchar()) != EOF){
        if ('A' <= c) {
        c = 'E' < c ? (c - 5) : (c + 21);
        }
        putchar(c);
    }
}


#include<iostream>
#include<string>
using namespace std;
 
int main()
{
    string s;
    while(getline(cin, s))
    {
        for(int i = 0; i < s.size(); i++)
        {
            if(s[i] <= 'E' && s[i] >= 'A')//处理小于E的
                s[i] += 21;
            else if(s[i] >= 'F' && s[i] <= 'Z')//处理正常的字母
                s[i] -= 5;
            else                       //处理空格或者其他字符
                continue;
        }
        cout<<s<<endl;
    }
    return 0;
}


/*

一个正整数可以分解成一个或多个数组的积。例如36=2*2*3*3，即包含2和3两个因子。NowCoder最近在研究因子个数的分布规律，现在给出一系列正整数，他希望你开发一个程序输出每个正整数的因子个数。

输入描述:
输入包括多组数据。
每组数据仅有一个整数n (2≤n≤100000)。


输出描述:
对应每个整数，输出其因子个数，每个结果占一行。
示例1
输入
30
26
20
输出
3
2
2
*/


链接：https://www.nowcoder.com/questionTerminal/e8fb8f89f5d147ec92fd8ecfefe89b0d
来源：牛客网

#include<stdio.h>
int main()
{
    int x, num, flag, pri[] = { 2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997 };
    while (~scanf("%d", &x))
    {
        num = 0;
        for (int i = 0;i < 168;i++)
        {
            flag = 0;
            while (x%pri[i] == 0)
            {
                if (x%pri[i] == 0)
                    x /= pri[i];
                flag = 1;
            }
            if (flag)
                num++;
        }
        if (x > 1)
            num++;
        printf("%d\n", num);
    }
    return 0;
}


/*
【题目解析】：求一个数字的因子（>=2的最小不能整除数字）个数
【解题思路】：从最小因子2到数字的最大因子数（数字的平方根）开始判断是否能够取余
可以则循环取余直到取余不为0，因子个数+1；否则使用下一个因子计算；
最终整除了各个因子数之后剩余的数字不为1则本身也是一个因子，因此因子数+1
*/
#include <iostream>
#include<math.h>
using namespace std;
int main()
{
int n,k,i;
while(cin >> n){
k=0;
for(i = 2; i <= sqrt(n); i++) {
if ((n % i) == 0) {
while((n % i) == 0){
n=n/i;
}
k++;
}
}
if(n!=1)
k++;
cout<<k<<endl;
}
return 0;
}

